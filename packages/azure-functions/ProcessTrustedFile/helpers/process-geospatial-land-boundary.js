import buildSignalRMessage from '../../Shared/build-signalr-message.js'
import { CoordinateSystemValidationError, ValidationError } from '@defra/bng-errors-lib'
import { blobStorageConnector } from '@defra/bng-connectors-lib'
import { processLandBoundary } from '@defra/bng-geoprocessing-service'

const GEOJSON_FILE_EXTENSION = '.geojson'
const OSGB26_SRS_AUTHORITY_CODE = '27700'
const REPROJECTED_TO_OSGB36 = 'reprojectedToOsgb36'
const VSIAZ_TRUSTED = '/vsiaz/trusted'

export default async function (context, config) {
  // Defect - BNGP-1711.
  // Add a timestamp to GeoJSON files created by GDAL so that the filename is unique.
  // If an attempt is made to open a file with the same name as an existing file generated by GDAL,
  // an error occurs until the function app is restarted.
  const currentIsoTime = new Date().toISOString()
  const isGeoJsonFile = config.fileConfig.fileExtension === GEOJSON_FILE_EXTENSION
  const tmpGeoJsonBlobName =
   `${config.fileConfig.fileDirectory}/${config.fileConfig.filename}${currentIsoTime}${GEOJSON_FILE_EXTENSION}`
  const tmpReprojectedGeoJsonBlobName = `${config.fileConfig.fileDirectory}/${REPROJECTED_TO_OSGB36}/${currentIsoTime}${GEOJSON_FILE_EXTENSION}`
  const geoJsonBlobName = `${config.fileConfig.fileDirectory}/${config.fileConfig.filename}${GEOJSON_FILE_EXTENSION}`
  const reprojectedGeoJsonBlobName = `${config.fileConfig.fileDirectory}/${REPROJECTED_TO_OSGB36}/${config.fileConfig.filename}${GEOJSON_FILE_EXTENSION}`

  const landBoundaryConfig = {
    bufferDistance: process.env.LAND_BOUNDARY_BUFFER_DISTANCE || 500,
    inputLocation: `${config.fileConfig.fileExtension === '.zip' ? '/vsizip' : ''}/vsiaz_streaming/trusted/${config.fileConfig.fileLocation}`,
    // Prepare to use the GDAL virtual file system to convert a geospatial land boundary uploaded by a user to GeoJSON (if needed).
    outputLocation: `${VSIAZ_TRUSTED}/${tmpGeoJsonBlobName}`,
    reprojectedOutputLocation: `${VSIAZ_TRUSTED}/${tmpReprojectedGeoJsonBlobName}`,
    gdalEnvVars: gdalEnvVars()
  }

  if (isGeoJsonFile) {
    // If a GeoJSON file has been uploaded it does not need converting to GeoJSON and writing back to blob storage.
    delete landBoundaryConfig.outputLocation
  }

  let signalRMessageArguments
  try {
    const mapConfig = await processLandBoundary(context.log, landBoundaryConfig)

    // Defect BNGP-1711.
    // If timestamped GeoJSON files have been created, remove the timestamp from the filenames using the
    // Azure blob storge API. This preserves the GeoJSON filenames so that dependent BNG software remains
    // unchanged and allows the GeoJSON files to be overwritten by the user if required.
    if (!isGeoJsonFile) {
      await moveBlob(tmpGeoJsonBlobName, geoJsonBlobName)
    }

    if (mapConfig.epsg !== OSGB26_SRS_AUTHORITY_CODE) {
      await moveBlob(tmpReprojectedGeoJsonBlobName, reprojectedGeoJsonBlobName)
    }

    signalRMessageArguments = [{
      location: geoJsonBlobName,
      mapConfig
    }]

    if (mapConfig.epsg !== OSGB26_SRS_AUTHORITY_CODE) {
      signalRMessageArguments[0].reprojectedLocation = reprojectedGeoJsonBlobName
    }
  } catch (err) {
    if (err instanceof CoordinateSystemValidationError) {
      signalRMessageArguments = [{
        authorityKey: err.authorityKey,
        errorCode: err.code
      }]
    } else if (err instanceof ValidationError) {
      signalRMessageArguments = [{ errorCode: err.code }]
    } else {
      signalRMessageArguments = [{ errorMessage: err.message }]
    }
  } finally {
    context.bindings.signalRMessages = [buildSignalRMessage(config.signalRMessageConfig, signalRMessageArguments)]
  }
}

const moveBlob = async (sourceBlobName, targetBlobName) => {
  const blobConfig = {
    source: {
      containerName: 'trusted',
      blobName: sourceBlobName
    },
    target: {
      containerName: 'trusted',
      blobName: targetBlobName
    }
  }
  return blobStorageConnector.moveBlob(blobConfig)
}

const gdalEnvVars = () => {
  return {
    AZURE_STORAGE_ACCOUNT: process.env.AZURE_STORAGE_ACCOUNT,
    AZURE_STORAGE_ACCESS_KEY: process.env.AZURE_STORAGE_ACCESS_KEY
  }
}
